/*
	Masked Input plugin for jQuery
	Copyright (c) 2007-2009 Josh Bush (digitalbush.com)
	Licensed under the MIT license (http://digitalbush.com/projects/masked-input-plugin/#license) 
	Version: 1.2.2 (03/09/2009 22:39:06)
*/

(function($) {
	var pasteEventName = ($.browser.msie ? 'paste' : 'input') + ".mask";
	var iPhone = (window.orientation != undefined);

	$.mask = {
		//Заранее заданные симольные определения
		definitions: {
			'9': "[0-9]",
			'3': "[0-3]",
			'1': "[0-1]",
			't': "[1-2]",
			'y': "[0189]",
			'a': "[A-Za-z]",
			'*': "[A-Za-z0-9]"
		}
	};

	$.fn.extend({
		// Вспомогательная функция работы с позицией каретки
		// Выдает начальную и конечную позицию выделения (если просто курсор то они равны)
		caret: function(begin, end) {
			if (this.length == 0) return;
			if (typeof begin == 'number') {
				end = (typeof end == 'number') ? end : begin;
				return this.each(function() {
					if (this.setSelectionRange) {
						this.focus();
						this.setSelectionRange(begin, end);
					} else if (this.createTextRange) {
						var range = this.createTextRange();
						range.collapse(true);
						range.moveEnd('character', end);
						range.moveStart('character', begin);
						range.select();
					}
				});
			} else {
				if (this[0].setSelectionRange) {
					begin = this[0].selectionStart;
					end = this[0].selectionEnd;
				} else if (document.selection && document.selection.createRange) {
					var range = document.selection.createRange();
					begin = 0 - range.duplicate().moveStart('character', -100000);
					end = begin + range.text.length;
				}
				return { begin: begin, end: end };
			}
		},
		unmask: function() { return this.trigger("unmask"); },
		mask: function(mask, settings) {
			if (!mask && this.length > 0) {
				var input = $(this[0]);
				var tests = input.data("tests");
				return $.map(input.data("buffer"), function(c, i) {
					return tests[i] ? c : null; // если tests[i] то символ c, иначе null
				}).join(''); // соединяем массив map в единый массив с помощью join()
			}
			settings = $.extend({
				placeholder: "_", // заполнитель по умолчанию - подчеркивание
				completed: null
			}, settings);

			var defs = $.mask.definitions; // заранее заданные определения
			var tests = [];
			var partialPosition = mask.length;
			var firstNonMaskPos = null;
			var len = mask.length;
			
			$(this).bind("blur", checkYearCorrect);

			$.each(mask.split(""), function(i, c) { // для каждого элемента массива маски
				if (c == '?') {
					len--;
					partialPosition = i;
				} else if (defs[c]) {
					tests.push(new RegExp(defs[c])); // добавляем новый элемент к массиву
					if(firstNonMaskPos==null)
						firstNonMaskPos =  tests.length - 1;
				} else {
					tests.push(null);
				}
			});

			return this.each(function() {
				var input = $(this);
				var buffer = $.map(mask.split(""), function(c, i) { 
					if (c != '?') return defs[c] ? settings.placeholder : c });
				var ignore = false;  			//Переменная для игнорирования клавиш управления
				var focusText = input.val();
				input.data("buffer", buffer).data("tests", tests);

				// Ищем следующую
				function seekNext(pos) {
					while (++pos <= len && !tests[pos]);
					return pos;
				};

				// Сдвиг влево
				function shiftL(pos) {
					while (!tests[pos] && --pos >= 0);
					for (var i = pos; i < len; i++) {
						if (tests[i]) {
							buffer[i] = settings.placeholder;
							var j = i; //seekNext(i); // Изменили чтобы работало без сдвига
							if (j < len && tests[i].test(buffer[j])) {
								buffer[i] = buffer[j];
							} else
								break;
						}
					}
					writeBuffer();
					input.caret(Math.max(firstNonMaskPos, pos));
				};

				// Сдвиг вправо
				function shiftR(pos) {
					for (var i = pos, c = settings.placeholder; i < len; i++) {
						if (tests[i]) {
							var j = seekNext(i);
							var t = buffer[i];
							buffer[i] = c;
							if (j < len && tests[j].test(t))
								c = t;
							else
								break;
						}
					}
				};
				
				// Наша функция для установки количества ошибок при вводе
				// Если количество ошибок ввода в поле превысила допустимое, то выводим сообщение
				function set_error_try(el) {
					var input = el;
					var pos = input.caret().begin;
					var input_val = input.val();
					var errcount = parseInt(input.attr("errcount"));
					if (!errcount) errcount = 0;
					if (errcount < 1) {
						errcount += 1;
						input.attr("errcount", errcount);
					}
					else {
						if (input_val.length != 4) {
							showTooltipForDateInput(input, "Введите дату в формате 'дд.мм.гггг' за период от 1800 до 2100 г.");
						}
						else {
							showTooltipForDateInput(input, "Введите год в формате 'гггг' за период от 1800 до 2100 г.");
						}
						input.attr("errcount", 0);
						input.val(input_val);
						input.caret(pos);
					}
					
					//если это дата и пустая строка то нужно очистить сохраненную дату
					if ( (input.attr('field_type') == 'date') && ( (input_val == '') || (input_val == input.attr('default_value'))) ){
						input.datepickerclear("clear");
					}
				}
				
				// Функция проверки даты. Добавлена нами.
				function checkDate(el, pos, c) {
					var inputValue = el.value;
					var inputLength = inputValue.length;
					var jq_el = $(el);
					var class_fields = jq_el.parent().parent();
					var sa_type = "";
					
					if ( (class_fields.hasClass("date")) || (class_fields.hasClass("date_period")) ) sa_type = "date";
					var id_date= jq_el.attr("id");
					if (sa_type != "date") {
						// Если это поле года в календарике
						if (id_date == "year_in_calendar") {
							if (pos == 0) {
								if ( (jq_el.caret().begin != jq_el.caret().end) && ((c == 1) || (c == 2)) ) { 
									inputValue = '';
									jq_el.val('');
								}
								
								if ((inputValue[1] < 8) && (c == 1)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[1] > 1) && (c == 2)) {
									set_error_try(jq_el);
									return false;
								}
								
							}
							
							if (pos == 1) {
								if ((inputValue[0] == 1) && (c < 8)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[0] == 2) && (c > 1)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 2) {
								if ((inputValue[1] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 3) {
								if ((inputValue[1] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
						}
						
						// Если это не дата то данную проверку не производим
						return true;
					}
					
					else {
						
						if (inputLength == 10) {// То есть если точная дата __.__.____ а не период 
							// проверяем правильность ввода дня (число должно быть меньше 32)
							if (pos == 0) {
								if (c > 3) {
									// Автоподстановка. Возвращаемое значение должно быть одновременно и true
									// а также это число+1 которое мы должны отобразить в подстановке
									return 1; // Возвращаем 1, значит подставляем в первую цифру числа 0
								}
								
								if (c == 3) {
									if ((inputValue[1] > 1)) {
										set_error_try(jq_el);
										return false;
									}
								}
							}
							
							if (pos == 1) {
								if ((inputValue[0] == 3) && (c > 1)) {
									set_error_try(jq_el);
									return false;
								}
																
								if ((inputValue[0] == 0) && (c == 0)) {
									set_error_try(jq_el);
									return false;
								}

							}
							
							// Автоподстановка для месяца
							if ((pos == 3) && (c > 1)) {
									return 1;
							}							
							
							// Актуально при редактировании
							if ((pos == 3) && (c == 1)) {
								if (inputValue[4] > 2) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							// проверяем правильность ввода месяца (число должно быть меньше 13)
							if (pos == 4) {
								if ((inputValue[3] == 1) && (c > 2)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[3] == 0) && (c == 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							// проверяем правильность ввода года (число должно быть меньше 13)
							if (pos == 7) {
								if ((inputValue[6] == 1) && (c < 8)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[6] == 2) && (c > 1)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 8) {
								if ((inputValue[7] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 9) {
								if ((inputValue[7] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
								hideTooltipForDateInput();
							}
							
							
							// Актуально при редактировании
							if (pos == 6) {
								if (((inputValue[7] == 1) || (inputValue[7] == 0)) && (c == 1)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[7] > 1) && (c == 2)) {
									set_error_try(jq_el);
									return false;
								}
							}
						
						}

						// Если дата период с __.__.____ по __.__.____
						if (inputLength == 26) {
							// проверяем первую дату (с __.__.____)
							
							if ((pos == 2) && (c > 3)) {
								return 1; 
							}
							
							if ((pos == 2) && (c == 3)) {
								if ((inputValue[3] > 1)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 3) {
								if ((inputValue[2] == 3) && (c > 1)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[2] == 0) && (c == 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if ((pos == 5) && (c > 1)) {
								return 1; 
							}
							
							// Актуально при редактировании
							if ((pos == 5) && (c == 1)) {
								if (inputValue[6] > 2) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 6) {
								if ((inputValue[5] == 1) && (c > 2)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[5] == 0) && (c == 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							// Актуально при редактировании
							if (pos == 8) {
								if (((inputValue[9] == 1) || (inputValue[9] == 0)) && (c == 1)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[9] > 1) && (c == 2)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							// проверяем правильность ввода года (число должно быть меньше 13)
							if (pos == 9) {
								if ((inputValue[8] == 1) && (c < 8)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[8] == 2) && (c > 1)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 10) {
								if ((inputValue[9] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 11) {
								if ((inputValue[9] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							
							// проверяем вторую дату (по __.__.____)
							if ((pos == 16) && (c > 3)) {
								return 1; 
							}
							
							// Актуально при редактировании
							if ((pos == 16) && (c == 3)) {
								if ((inputValue[17] > 1)) {
									set_error_try(jq_el);
									return false;
								}
							}						
							
							if (pos == 17) {
								if ((inputValue[16] == 3) && (c > 1)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[16] == 0) && (c == 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if ((pos == 19) && (c > 1)) {
								return 1; 
							}
							
							// Актуально при редактировании
							if ((pos == 19) && (c == 1)) {
								if (inputValue[20] > 2) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 20) {
								if ((inputValue[19] == 1) && (c > 2)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[19] == 0) && (c == 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							// Актуально при редактировании
							if (pos == 22) {
								if (((inputValue[23] == 1) || (inputValue[23] == 0)) && (c == 1)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[23] > 1) && (c == 2)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							// проверяем правильность ввода года (число должно быть меньше 13)
							if (pos == 23) {
								if ((inputValue[22] == 1) && (c < 8)) {
									set_error_try(jq_el);
									return false;
								}
								
								if ((inputValue[22] == 2) && (c > 1)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 24) {
								if ((inputValue[23] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
							}
							
							if (pos == 25) {
								if ((inputValue[23] == 1) && (c != 0)) {
									set_error_try(jq_el);
									return false;
								}
								
								hideTooltipForDateInput();
							}
					}
					
					return true;
					}
				}

				function keydownEvent(e) {
					var pos = $(this).caret();
					var k = e.keyCode;
					ignore = (k < 16 || (k > 16 && k < 32) || (k > 32 && k < 41));

					//удаляем выделенное перед работой
					if ((pos.begin - pos.end) != 0 && (!ignore || k == 8 || k == 46))
						clearBuffer(pos.begin, pos.end);

					//backspace, delete, и escape получают специальное обращение
					if (k == 8 || k == 46 || (iPhone && k == 127)) {//backspace/delete
						shiftL(pos.begin + (k == 46 ? 0 : -1));
						if (input.val() == input.attr('default_value')) {
							hideTooltipForDateInput(); // Если поле пустое прячем подсказку
						}
						return false;
					} else if (k == 27) {//escape
						input.val(focusText);
						input.caret(0, checkVal());
						return false;
					}
				};

				function keypressEvent(e) {
					if (ignore) {
						ignore = false;
						//Заплатка Mac FF бага для backspace
						return (e.keyCode == 8) ? false : null;
					}
					e = e || window.event;
					
					var k = e.charCode || e.keyCode || e.which;
					var jq_this = $(this);
					var pos = jq_this.caret();

					if (e.ctrlKey || e.altKey || e.metaKey) {//Игнорируем
						return true;
					} else if ((k >= 32 && k <= 125) || k > 186) {//печатные символы
						var p = seekNext(pos.begin - 1);
						if (p < len) {
							var c = String.fromCharCode(k);
							var checkDateResult;
							if ( checkDateResult = checkDate(this, p, c) ) {
								if (tests[p].test(c)) {

										// Автоподстановка для даты
										if ((checkDateResult === 1) || (checkDateResult === 2)){
											buffer[p] = checkDateResult - 1;
											p++;
											buffer[p] = c;
											p++;
										}
										else {
											buffer[p] = c;
										}
										
										//shiftR(p); // Убрали сдвиг вправо при вводе символа (то есть замену следующего)
										writeBuffer();
										var next = seekNext(p);
										jq_this.caret(next);
										if (settings.completed && next == len)
											settings.completed.call(input);
								}
								else {
									set_error_try(jq_this);
								}
							}
						}
					}
					return false;
				};

				function clearBuffer(start, end) {
					for (var i = start; i < end && i < len; i++) {
						if (tests[i])
							buffer[i] = settings.placeholder;
					}
				};

				function writeBuffer() { 
					return input.val(buffer.join('')).val(); 					
				};

				function checkVal(allow) {
					//пытаемся вставить символы, где они подходят
					var test = input.val();
					var lastMatch = -1;
					for (var i = 0, pos = 0; i < len; i++) {
						if (tests[i]) {
							buffer[i] = settings.placeholder;
							while (pos++ < test.length) {
								var c = test.charAt(pos - 1);
								if (tests[i].test(c)) {
									buffer[i] = c;
									lastMatch = i;
									break;
								}
							}
							if (pos > test.length)
								break;
						} else if (buffer[i] == test[pos] && i!=partialPosition) {
							pos++;
							lastMatch = i;
						} 
					}
					if (!allow && lastMatch + 1 < partialPosition) {
						input.val("");
						clearBuffer(0, len);
					} else if (allow || lastMatch + 1 >= partialPosition) {
						writeBuffer();
						if (!allow) input.val(input.val().substring(0, lastMatch + 1));
					}
					return (partialPosition ? i : firstNonMaskPos);
				};

				if (!input.attr("readonly"))
					input
					.one("unmask", function() {
						input
							.unbind(".mask")
							.removeData("buffer")
							.removeData("tests");
					})
					.bind("focus.mask", function() {
						focusText = input.val();
						var pos = checkVal();
						writeBuffer();
						setTimeout(function() {
							if (pos == mask.length)
								input.caret(0, pos);
							else
								input.caret(pos);
						}, 0);
					})
					.bind("blur.mask", function() {
						checkVal();
						if (input.val() != focusText)
							input.change();
					})
					.bind("keydown.mask", keydownEvent)
					.bind("keypress.mask", keypressEvent)
					.bind(pasteEventName, function() {
						setTimeout(function() { input.caret(checkVal(true)); }, 0);
					});

				checkVal(); // выполняем первоначальную проверку для существующих значений
			});
		}
	});
})(jQuery);